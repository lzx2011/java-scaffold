package interview;

/**
 * ClassName: Algorithm <br/>
 * Function: <br/>
 *
 * @author gary.liu
 * @date 2019/9/29
 */
public class Algorithm {
/** pdd
 1.快速排序，回文打印问题
 2.层次遍历树并输出每层的层级
 3.手撸代码，最长不重复子串
 4.实现消费者生产者模型
 5.集合类熟悉吧，写一个题目，一个字符串集合，找出pdd并且删除，我直接写了一个list然后for循环判断相等时删除，她说明显问题，我才发现list直接删位置会出错，于是我说改用数组，她说不太符合要求，所以应该使用iterator删除会好一点，修改会反映到集合类，并且不会出错。
 6.回溯法一题，动态规划写了一题，要求是代码写完整
 7.写了一个阻塞队列、一个区间包含的算法题，一个单例模式。
 8.二叉树的后序遍历，非递归算法。
    用一个栈可以实现，先压自己，再压右节点，再压左节点。不过我卡在一半没写完，面试官说有思路就行了，今天就面到这，然后就溜了，发现已经没人了。
 9.图的种类，应用场景

 10.红黑树的应用场景（幸好没多问，就问了场景），解决什么问题。
 11.给一个字符串（长度4k）,顺时针打印成正方形，这个讨论了有点久，然后问怎么优化。
    我开始给的方法：用二维数组存好
 例如abcdefghijkl(k = 3)
 打印结果：
 ```
 abcd
 l  e
 k  f
 jihg
 ```
 优化后的：
 第一行和最后一行直接打，中间的，判断头和尾在字符串中的位置即可。
 比如，i从1开始，
 第i行的开头在字符串str中的位置就是str.length() - i
 第i行最后一个字符在str中的位置:k + i

 12.最大子数组，我本来想说dp法的，后来觉得太套路了，直接说了空间和时间复杂度最小的（从dp演化而来），
 leetcode入门题。。代码如下，基本一致

 public int maxSubArray(int[] nums) {
 if(nums == null) return Integer.MIN_VALUE;
 int sum = 0;
 int left = 0;
 int res = Integer.MIN_VALUE;
 for(int i = 0; i < nums.length; i++){
 if(sum < 0){
 sum = nums[i];
 left = i;
 }
 else{
 sum += nums[i];
 }
 res = Math.max(res, sum);
 }
 return res;
 }

 13.最多共同好友，是这样：有很多用户，每个用户都有好友，现在给定一个用户，让查和他共同好友最多的人（这个人和那个用户不是同一个人）
 比如：
 id 好友
 0 1 2 3
 1 0
 2 0 3
 3 0 2 4
 4 3
 我说了我的方法（用集合，暴力）
 面试官提示：如果用户特别多，但是好友关系很少，怎么办。
 我想了会。给出优化方案：只查找给定用户的好友的好友即可。







 */

/** kuaishou
 1.一道算法题，一个二维矩阵进行逆置操作，也就是行变列列变行
 2. 扩展一下，二维数组存在500g的文件中，怎么做才能完成上面算法的操作，我就说先按行拆分，最后再拼接。
 3. 扩展两下，一行数据就会超出内存，应该怎么做，那就按列拆分，最后合并。
 */
}
