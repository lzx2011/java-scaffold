# Java高级特性

### 3.Java GC机制？GC Roots有哪些？
    GC（Garbage Collection)当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆（heap）中的所有对象。通过这种方式确定哪些对象是"可达的"，哪些对象是"不可达的".当GC确定一些对象为"不可达"时，GC就有责任回收这些内存空间。
 新生代（Eden：survivor1：survivor2=8：1：1），老年代（new：old=1：2），永久代
 可达性分析法：一个对象在没有任何强引用指向他或该对象通过根节点不可达时需要被垃圾回收器回收；
 引用计数法：引用计数法有一个缺陷就是无法解决循环引用问题。
    一个对象可以属于多个root，GC root有几下种：
 Class - 由系统类加载器(system class loader)加载的对象，这些类是不能够被回收的，他们可以以静态字段的方式保存持有其它对象。我们需要注意的一点就是，通过用户自定义的类加载器加载的类，除非相应的java.lang.Class实例以其它的某种（或多种）方式成为roots，否则它们并不是roots，.
 Thread - 活着的线程
 Stack Local - Java方法的local变量或参数
 JNI Local - JNI方法的local变量或参数
 JNI Global - 全局JNI引用
 Monitor Used - 用于同步的监控对象
 Held by JVM - 用于JVM特殊目的由GC保留的对象，但实际上这个与JVM的实现是有关的。可能已知的一些类型是：系统类加载器、一些JVM知道的重要的异常类、一些用于处理异常的预分配对象以及一些自定义的类加载器等。然而，JVM并没有为这些对象提供其它的信息，因此需要去确定哪些是属于"JVM持有"的了。
 https://www.cnblogs.com/w-wfy/p/6415768.html

### 1、GC原理，分代机制，可达性分析 
    GC（Garbage Collection)当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆（heap）中的所有对象。通过这种方式确定哪些对象是"可达的"，哪些对象是"不可达的".当GC确定一些对象为"不可达"时，GC就有责任回收这些内存空间。
    新生代（Eden：survivor1：survivor2=8：1：1），老年代（new：old=1：2），永久代
    可达性分析法：一个对象在没有任何强引用指向他或该对象通过根节点不可达时需要被垃圾回收器回收；
    引用计数法：引用计数法有一个缺陷就是无法解决循环引用问题。	
### 2、JVM参数有哪几种，如何调优？ 
   *设定堆内存大小，这是最基本的。
    1. -Xms：启动JVM时的堆内存空间。
    2. -Xmx：堆内存最大限制。
   *设定新生代大小。
   *新生代不宜太小，否则会有大量对象涌入老年代。
    1. -XX:NewRatio：新生代和老年代的占比。
    2. -XX:NewSize：新生代空间。
    3. -XX:SurvivorRatio：伊甸园空间和幸存者空间的占比。
    4. -XX:MaxTenuringThreshold：对象进入老年代的年龄阈值。 
### 3、JMM特性有哪些？ 
   Java内存模型具有三个特性：原子性、可见性和有序性。 
### 4、jstack，jstat，jmap，jhat命令，MAT等如何使用，使用场景？ 
   jstack：生成当前时刻的线程快照。jstack命令主要用来查看Java线程的调用堆栈的，可以用来分析线程问题（如死锁）。
   jstat：用于监控虚拟机各种运行状态信息的命令行工具。他可以显示本地或远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。包括了对Heap size和使用请看，垃圾回收状况的监控。
   jmap：生成堆转储快照（heap dump）,堆Dump是反应Java堆使用情况的内存镜像，其中主要包括系统信息、虚拟机属性、完整的线程Dump、所有类和对象的状态等。 一般，在内存不足（OOM）、GC异常等情况下，我们就会怀疑有内存泄露。这个时候我们就可以制作堆Dump来查看具体情况，分析原因。
   jhat：(Java Heap Analysis Tool),是一个用来分析java的堆情况的命令。之前的文章讲到过，使用jmap可以生成Java堆的Dump文件。生成dump文件之后就可以用jhat命令，将dump文件转成html的形式，然后通过http访问可以查看堆情况。  
   jinfo可以输出java进程、core文件或远程debug服务器的配置信息。
### 5、堆外内存？
    和堆内内存相对应，堆外内存就是把内存对象分配在Java虚拟机的堆以外的内存，这些内存直接受操作系统管理（而不是虚拟机），这样做的结果就是能够在一定程度上减少垃圾回收对应用程序造成的影响。常见应用缓存
### 6、生产者消费者模式？
   该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。
   在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。 
### 7、频繁GC问题或内存溢出如何分析解决？
   一、使用jps查看进程ID
二、使用jstat -gc 3331 250 20 查看gc情况，一般比较关注PERM区的情况，查看GC的增长情况。
三、使用jstat -gccause：额外输出上次GC原因
四、使用jmap -dump:format=b,file=heapDump 3331生成堆转储文件
五、使用jhat或者可视化工具（Eclipse Memory Analyzer 、IBM HeapAnalyzer）分析堆情况。
六、结合代码解决内存溢出或泄露问题。
### 8、cpu过高如何分析解决？
    top命令找出有问题Java进程及线程id：
开启线程显示模式
按CPU使用率排序
记下Java进程id及其CPU高的线程id
用进程id作为参数，jstack有问题的Java进程
手动转换线程id成十六进制（可以用printf %x 1234）
查找十六进制的线程id（可以用grep）
查看对应的线程栈
参考：https://github.com/oldratlee/useful-scripts/blob/master/docs/java.md     http://www.blogjava.net/hankchen/archive/2012/05/09/377735.html
### 9、Java虚拟机的构成，以及一个Java对象的生命周期，还有堆栈和方法区中存储的内容？
    Java虚拟机的构成：classloader系统（bootstrap，Extension，application classloader），Runtime data areas（堆，方法区，java栈，程序计数器，本地方法栈），execution engine（JIT），本地方法接口，本地方法库。
    Java对象生命周期：对象基本上都是在jvm的堆区中创建，在创建对象之前，会触发类加载（加载、连接、初始化），当类初始化完成后，根据类信息在堆区中实例化类对象，初始化非静态变量、非静态代码以及默认构造方法，当对象使用完之后会在合适的时候被jvm垃圾收集器回收。
    堆:存储对象实例以及数组值的区域，字符串常量池。
    栈：用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
    方法区：用于存储每一个类的结构信息，例如运行时常量池，成员变量和常量、静态变量和即时编译器编译后的代码等数据。构造函数和普通函数的字节码内容，还包括一些在类、实例、接口初始化时用到的特殊方法。
### 10、 JVM的GC过程，包括一些实际问题的分析，比如说明一个现象，让你分析可能是什么原因会导致这样的问题？
    
### 11、Full GC和Minor GC触发的条件
    * 当年轻代内存满时，会引发一次普通minor GC，该GC仅回收年轻代。需要强调的时，年轻代满是指Eden代满，Survivor满不会引发GC
* 当年老代满时会引发Full（major） GC，Full GC将会同时回收年轻代、年老代
* 当永久代满时也会引发Full GC，会导致Class、Method元信息的卸载
### 12、GC Roots的选择？
   1. 虚拟机栈中引用的对象（本地变量表）
　　2. 方法区中静态属性引用的对象
　　3. 方法区中常量引用的对象
　　4.本地方法栈中引用的对象（Native对象）
为什么：GC管理的主要区域是Java堆，一般情况下只针对堆进行垃圾回收。方法区、栈和本地方法区不被GC所管理,因而选择这些区域内的对象作为GC roots,被GC roots引用的对象不被GC回收。
### 12、GC圾收集的方法有哪些?
	标记-清除（产生内存碎片），复制算法（新生代），标记-整理（老年代），分代收集（不同代使用不同方法）
### 13、 ClassLoader的加载过程,简述java类加载机制,类加载器双亲委派模型机制?
    	类从被加载到jvm内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。
	虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的java类型。
	当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，由子类去完成类的加载。
### 13、什么是类加载器，类加载器有哪些?
	实现通过类的权限定名获取该类的二进制字节流的代码块叫做类加载器。
1. 启动类加载器(Bootstrap ClassLoader)用来加载java核心类库，无法被java程序直接引用。如：rt.jar、resources.jar、charsets.jar等
2. 扩展类加载器(extensions class loader):它用来加载 Java 的扩展库。
3. 系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。
4. 用户自定义类加载器，通过继承 java.lang.ClassLoader类的方式实现。
### 14、Java 8 的新特性等？
     Lambdas表达式，Functional接口，接口默认方法，方法引用，重复注解，
     http://www.importnew.com/11908.html
### 15、常用设计模式，如单例？
    使用volatile的双重校验锁
	- 工厂模式：工厂类可以根据条件生成不同的子类实例，这些子类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作（多态方法）。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。 
	- 代理模式：给一个对象提供一个代理对象，并由代理对象控制原对象的引用。实际开发中，按照使用目的的不同，代理可以分为：远程代理、虚拟代理、保护代理、Cache代理、防火墙代理、同步化代理、智能引用代理。 
	- 适配器模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起使用的类能够一起工作。 
	- 模板方法模式：提供一个抽象类，将部分逻辑以具体方法或构造器的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法（多态实现），从而实现不同的业务逻辑。 
除此之外，还可以讲讲上面提到的门面模式、桥梁模式、单例模式、装潢模式（Collections工具类和I/O系统中都使用装潢模式）等，反正基本原则就是拣自己最熟悉的、用得最多的作答，以免言多必失。
### 16、在进行数据库编程时，连接池有什么作用？ 
	由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每次建立连接都需要进行TCP的三次握手，释放连接需要进行TCP四次握手，造成的开销是不可忽视的），为了提升系统访问数据库的性能，可以事先创建若干连接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭连接，从而避免频繁创建和释放连接所造成的开销，这是典型的用空间换取时间的策略（浪费了空间存储连接，但节省了创建和释放连接的时间）。池化技术在Java开发中是很常见的，在使用线程时创建线程池的道理与此相同。基于Java的开源数据库连接池主要有：C3P0、Proxool、DBCP、BoneCP、Druid等。
